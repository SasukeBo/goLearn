# 第4章 接口

**变量和实例**

变量在传统的概念里有两层含义，变量的值和变量类型，很难和类型的方法产生联想。

我们使用”实例“这个概念，实例里面蕴含着变量值，变量类型和附着在类型上的方法等语义。

实例和面向对象编程中的对象的概念相似，接口变量只有值和类型的概念，所以接口类型变量仍然称为接口变量。

接口内部存放的具体类型变量被称为接口指向的实例。接口只有声明没有实现，所以定义一个新接口，通常又变成声明
一个新接口，定义接口和声明接口二者通用，代表相同的意思。


**空接口**

最常使用的接口字面量类型就是空接口`interface{}`，由于空接口的方法集为空，所以任意类型都被认为实现了空接口，
任意类型的实例都可以赋值或传递给空接口，包括非命名类型的实例。

## 基本概念

### 接口声明

Go语言的接口分为接口字面量类型和接口命名类型，接口的声明使用interface关键字。

接口字面量类型的声明语法如下：

```go
interface {
  MethodSignature1
  MethodSignature2
}
```

接口命名类型使用type关键字声明，语法如下：
```go
type InterfaceName interface {
  MethodSignature1
  MethodSignature2
}
```

接口定义大括号内可以是方法声明的集合，也可以嵌入另一个接口类型匿名字段，还可以是二者的混合。

接口支持嵌入匿名接口字段，就是一个接口定义里面可以包括其他接口。例如：
```go
type Reader interface {
  Read(p []byte) (n int, err error)
}

type Writer interface {
  Write(p []byte) (n int, err error)
}

// 如下三种声明是等价的，最终展开模式都是第三种格式

type ReadWriter interface {
  Reader
  Writer
}

type ReadWriter interface {
  Reader
  Write(p []byte) (n int, err error)
}

type ReadWriter interface {
  Read(p []byte) (n int, err error)
  Write(p []byte) (n int, err error)
}
```

**方法声明**

严格意义上的函数签名是函数的字面量类型。函数签名是不包括函数名的。

而函数声明是指带上函数名的函数签名。

接口定义使用方法声明，而不是方法签名，因为方法名是接口的组成部分。
```go
// 方法声明 = 方法名 + 方法签名
MethodName (InputTypeList)OutputTypeList
```

接口中的方法声明非常类似于C语言中的函数声明的概念。

**声明新接口类型的特点**

1. 接口的命名一般以 `er` 结尾。
1. 接口定义的内部方法声明不需要func引导。
1. 在接口定义中，只有方法声明没有方法实现。

### 接口初始化

接口只有被初始化为具体的类型时才有意义。

接口作为一个胶水层或抽象层，起到抽象和适配的作用。没有初始化的接口变量，其默认值是nil。
```go
var i io.Reader
fmt.Printf("%T\n", i) // <nil>
```

**实例赋值接口**

如果具体类型实例的方法集是某个接口的方法集的超集。则称该具体类型实现了接口。可以将该具体类型的
实例直接赋值给接口类型的变量，此时编译器会进行静态的类型检查。接口被初始化后，调用接口的方法就
相当于调用接口绑定的具体类型的方法，这就是接口调用的语义。

**接口变量赋值接口变量**

已经初始化的接口类型变量a直接复制给另一种接口变量b，要求b的方法集是a的方法集的子集。此时Go编译器
会在编译时进行方法集静态检查。这个过程也是接口初始化的一种方式，此时接口变量b绑定的具体实例是接口
变量a绑定的具体实例的副本。

```go
file, _ := os.OpenFile("notes.txt", os.O_RDWR|os.O_CREATE, 0755)

var rw io.ReadWriter = file
// io.ReadWriter接口可以直接赋值给io.Writer接口变量
var w io.Writer = rw
```

### 接口方法调用

接口方法调用和普通的函数调用是有区别的。

接口方法调用的最终地址是在运行期决定的，将具体类型变量赋值给接口后，会使用具体类型的方法指针初始化接口变量，
当调用接口变量的方法时，实际上是间接地调用实例的方法。接口方法调用不是一种直接的调用，有一定的运行时开销。

直接调用未初始化的接口变量的方法会产生panic。

[example1.go](example1.go)

### 接口的动态类型和静态类型

**动态类型**

接口绑定的具体实例的类型称为接口的动态类型。
接口可以绑定不同类型的实例，所以接口的动态类型是随着其绑定的不同类型实例而发生变化的。

**静态类型**

接口被定义时，其类型就已经被确定了，这个类型叫接口的静态类型。

静态类型的本质特征就是接口的方法签名集合。两个接口如果方法签名集合相同，则这两个接口在语义上完全等价，它们
之间不需要强制类型转换。Go编译器校验两个接口是否能赋值是比较二者的方法集，而不是看具体接口类型名。

a接口的方法集是A，b接口的方法集是B，如果B是A的子集，则a的接口变量可以直接赋值给b的接口变量。

## 接口运算

接口是一个抽象的类型，接口像一层胶水，可以灵活的解耦软件的每一个层次，基于接口编程是Go语言编程的基本思想。

### 类型断言（Type Assertion）

接口类型断言的语法形式如下：
```go
// i必须是接口变量
i.(TypeName)
```

**接口查询的两层语义**

1. 如果TypeName是一个具体类型名，则类型断言用于判断接口变量i绑定的实例类型是否就是具体类型TypeName。
1. 如果TypeName是一个接口类型名，则类型断言用于判断接口变量i绑定的实例类型是否同时实现了TypeName接口。

**接口断言的两种语法表现**

*直接赋值模式：*
```go
o := i.(TypeName)
```

语义分析：
1. TypeName是具体类型名，此时如果接口i绑定的实例类型就是具体类型TypeName，则变量o的类型就是TypeName，变量
o的值就是接口绑定的实例值的副本（当然实例可能是指针值，那就是指针值的副本）。
2. TypeName是接口类型名，如果接口i绑定的实例类型满足接口类型TypeName，则变量o的类型就是接口类型TypeName，o
底层绑定的具体类型实例是i绑定的实例的副本（当然实力可能是指针值，那就是指针值的副本）。
3. 如果上述两种情况都不满足，则程序抛出panic。

[example2.go](example2.go)

*comma, ok表达式模式如下：*
```go
if o, ok := i.(TypeName); ok {

}
```
语义分析：
1. TypeName是具体类型名，此时如果接口i绑定的实例类型就是具体类型TypeName，则ok为true，变量o的类型就是TypeName，
变量o的值就是接口绑定的实例值的副本（当然实例可能是指针值，那就是指针值副本）。
1. TypeName是接口类型名，此时如果接口i绑定的实例的类型满足接口类型TypeName，则ok为true，变量o的类型就是接口类型TypeName，
o底层绑定的具体类型实例是i绑定的实例的副本（当然实例可能是指针值，那就是指针值的副本）。
1. 如果上述两个都不满足，则OK为false，变量o是TypeName类型的零值，此种条件分支下程序逻辑不应该再去引用o，因为此时的o没有意义。

[example3.go](example3.go)

### 类型查询（Type Switches）

接口类型查询的语法格式如下：

```go
switch v := i.(type) {
  case type1:
    xxxx
  case type2:
    xxxx
  default:
    xxxx
}
```

**语义分析**

接口查询有两层语义，一是查询一个接口变量底层绑定的底层变量的具体类型是什么，二是查询接口变量绑定的底层变量是否还实现了其他接口。

1. i必须是接口类型

具体类型实例的类型是静态的，在类型声明后就不再变化，所以具体类型的变量不存在类型查询，类型查询一定是对一个接口变量进行操作。

```go
var i io.Reader
switch v := i.(type) { // 此处i是为未初始化的接口变量，所以v为nil
  case nil:
    fmt.Printf("%T\n", v)
  default:
    fmt.Printf("%T\n", v)
}
```

2. case子句后面可以跟非接口类型名，也可以跟接口类型名，匹配是按照case子句的顺序进行的。
